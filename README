=== Event models
- a task event is described by a subclass of Event. When this kind of event is 
  fired, the event instance is built by calling ::new on this class. 
- events are created by event generators. The EventGenerator classes are the uniform interface
  from which everything else is done - for instance, event signalling methods in Task are only
  sugar-coating interfaces on the EventGenerator interface. Example of event generators:
  * TaskEventGenerator for event generated by tasks
  * AndGenerator, OrGenerator, which aggregates a list of events
  * EverGenerator which implements the 'ever' semantic

=== Event structure
- every event structure but signalling[1] are modules declared in Roby::EventStructure

=== Task structure
- every task structure is declared in Roby::TaskStructure
	
=== Planning
- The planning is in spirit similar to HTN planning: methods are used to develop 
  a task tree
- A method shall produce a Task object. The kind of Task object a particular method
  can produce is specified by the :returns attribute (see below for inheritance semantics)

=== Inheritance semantics    
- Task inheritance semantics
  * a task subclass has all events of its parent class
  * some event attributes can be overriden. The rules are:
    - a non controlable event can become a controlable one, but not the other way around
    - a non-terminal event can become a terminal one, but not the other way around

- Planning inheritance semantics
  * added method models, for now one model for each inheritance level. Maybe go
    back at using one model for everybody
  * a subclass can overload a specific method by setting :id explicitely
  * the :returns option can be overriden as follows:
    - the :returns of a method should be a subclass of the :returns of its model
      and of the overloaded methods (methods in the inheritance hierarchy with the
      same id)
    - you cannot overload a method model, because it would lead to inconsistencies:
      if a method in the parent planner is defined w.r.t. the parent method model,
      then this method could be inconsistent with the method model defined in the 
      submodel
  * a model is frozen as soon as a method is defined based on it

=== Current limitations
- For now, OrGenerator and AndGenerator cannot be used to route inside a task (i.e. fire
  non-controlable events). Maybe fix that (check that all input events are from the same
  task than the output)


