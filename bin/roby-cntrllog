#! /usr/bin/ruby
#
require 'optparse'
require 'set'
require 'enumerator'

do_cumulative = false
parser = OptionParser.new do |opts|
    opts.banner = "roby-cntrllog [options]Â [modules]\nDisplays control timing logs which are saved by the :log option of Control::run"
    opts.separator ""
    opts.on("-v", "--cumulative", "display timings w.r.t. cycle beginning instead of durations") do
	do_cumulative = true
    end
    opts.on("--help", "this help") do 
	puts opts
	puts
	exit
    end
end
parser.parse! ARGV

def timeval_to_s(t)
    '%02i:%02i:%02i.%03i' % [t.tv_sec / 3600, t.tv_sec % 3600 / 60, t.tv_sec % 60, t.tv_usec / 1000]
end

REF_TIMING = :start
ALL_TIMINGS = [ :real_start, :server, :events, :events_exceptions, :structure_check, :structure_check_exceptions, :fatal_structure_errors, :garbage_collect, :ruby_gc, :end, :pass, :expected_sleep, :sleep ]

if ARGV.empty?
    STDERR.puts "no file given on command line, reading stdin"
end
begin
    header = ([REF_TIMING] + ALL_TIMINGS).enum_for(:each_with_index).
       map { |n, i| "#{i + 1}_#{n}" }.
       join("\t")

    puts header
    loop do
	timings = Marshal.load(ARGF)
	ref = timings.delete(REF_TIMING)

	unknown_timings = (timings.keys.to_set - ALL_TIMINGS.to_set)
	raise "invalid list of timings: unknown #{unknown_timings.to_a.join(", ")}" unless unknown_timings.empty?
	timings = ALL_TIMINGS.map do |name|
	    timings[name]
	end

	result = [timeval_to_s(ref)]
	if do_cumulative
	    timings.inject(ref) do |last, t| 
		t ||= last
		result << (t - ref)
		t
	    end
	else
	    timings.inject(ref) do |last, t| 
		t ||= last
		result << (t - last)
		t
	    end
	end

	puts result.join("  ")
    end
rescue EOFError
end
