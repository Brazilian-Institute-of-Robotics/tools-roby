#! /usr/bin/env ruby
#
require 'optparse'
require 'set'
require 'enumerator'

def timeval_to_s(t)
    '%02i:%02i:%02i.%03i' % [t.tv_sec / 3600, t.tv_sec % 3600 / 60, t.tv_sec % 60, t.tv_usec / 1000]
end

class TimingLog
    REF_TIMING = :start
    ALL_TIMINGS = [ :real_start, :server, :events, 
	:events_exceptions, :structure_check, :structure_check_exceptions, 
	:fatal_structure_errors, :garbage_collect, :application_errors, :end, 
	:expected_ruby_gc, :ruby_gc, :expected_sleep, :sleep ]

    NUMERIC_FIELDS = [:cycle_index, :live_objects, :object_allocation]

    ALL_FIELDS = ALL_TIMINGS | NUMERIC_FIELDS

    attr_reader :cycle_size
    attr_reader :io
    def initialize(io)
	@io = io
	rewind
    end
    def rewind
	io.seek(0)
	@cycle_size = Marshal.load(io)
    end

    def each_cycle(cumulative = false)
	loop do
	    result  = []
	    data = timings = Marshal.load(io)
	    ref     = timings.delete(REF_TIMING)
	    result << ref

	    unknown_timings = (timings.keys.to_set - ALL_FIELDS.to_set)
	    raise "invalid list of timings: unknown #{unknown_timings.to_a.join(", ")}" unless unknown_timings.empty?
	    timings = ALL_TIMINGS.map do |name|
		timings[name]
	    end

	    if cumulative
		timings.inject(ref) do |last, time| 
		    time ||= last
		    result << time - ref
		    time
		end
	    else
		timings.inject(ref) do |last, time| 
		    time ||= last
		    result << time - last
		    time
		end
	    end

	    yield(data.values_at(*NUMERIC_FIELDS), result)
	end
    rescue EOFError
    rescue ArgumentError => e
	if e.message =~ /marshal data too short/
	    STDERR.puts "File truncated"
	else raise
	end
    end
end

def stats(file)
    last_start = nil
    mean, stdev = nil
    count = 0

    mean_cycle  = 0
    stdev_cycle = 0

    # Compute mean value
    file.each_cycle(false) do |numeric, timings|
	if !mean
	    mean  = Array.new(numeric.size + timings.size, 0.0)
	end

	# Compute mean value
	start = timings.shift + timings.first
	if last_start
	    mean_cycle += start - last_start
	end
	last_start = start 

	(numeric + timings).each_with_index { |v, i| mean[i] += v }
	count += 1
    end
    mean.map! { |v| v / count }
    mean_cycle /= count

    last_start = nil
    file.rewind
    stdev = Array.new(mean.size, 0.0)
    file.each_cycle(false) do |numeric, timings|
	start = timings.shift + timings.first
	if last_start
	    stdev_cycle += (start - last_start - mean_cycle)**2
	end
	last_start = start

	(numeric + timings).each_with_index { |v, i| stdev[i] += (v - mean[i]) ** 2 }
    end
    stdev.map! { |v| Math.sqrt(v / count) }

    format = "%30s % 4.2f % 4.2f"
    puts format % ["cycle", mean_cycle * 1000, Math.sqrt(stdev_cycle / count) * 1000]
    TimingLog::NUMERIC_FIELDS.each_with_index do |name, i|
	puts format % [name, mean[i], stdev[i]] unless name == :cycle_index
    end

    (TimingLog::ALL_TIMINGS).each_with_index do |name, i|
	i += TimingLog::NUMERIC_FIELDS.size
	puts format % [name, mean[i] * 1000, stdev[i] * 1000]
    end
end

def display(timings, cumulative)

    header = ([TimingLog::REF_TIMING] + TimingLog::ALL_TIMINGS + TimingLog::NUMERIC_FIELDS).enum_for(:each_with_index).
       map { |n, i| "#{i + 1}_#{n}" }.
       join("\t")

    puts header
    timings.each_cycle(cumulative) do |numeric, results|
	print "#{timeval_to_s(results.shift)} "
	print results.join(", ")
	print " "
	puts numeric.join(" ")
    end
end

mode = :display
cumulative = false
parser = OptionParser.new do |opts|
    opts.banner = "roby-cntrllog [options]Â [modules]\nDisplays control timing logs which are saved by the :log option of Control::run"
    opts.separator ""
    opts.on("-s", "--stats", "display statistics instead of samples") do 
	mode = :stats
    end
    opts.on("-v", "--cumulative", "display timings w.r.t. cycle beginning instead of durations") do
	cumulative = true
    end
    opts.on("--help", "this help") do 
	puts opts
	puts
	exit
    end
end
parser.parse! ARGV
if ARGV.empty?
    STDERR.puts "no file given on command line, reading stdin"
end

#display_timings(cumulative)
File.open(ARGV[0]) do |io|
    timings = TimingLog.new(io)
    if mode == :stats
	stats(timings)
    else
	display(timings, cumulative)
    end
end

