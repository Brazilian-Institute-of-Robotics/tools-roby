#! /usr/bin/ruby
require 'roby'
require 'roby/log/logger'
require 'roby/log/drb'
require 'roby/log/marshallable'

require 'roby/log/execution-state'
require 'roby/log/relations'
require 'zlib'

require 'optparse'

module Roby::Log
    def self.open(file, &block)
	if file =~ /\.gz$/
	    Zlib::GzipReader.open(file, &block)
	else
	    File.open(file, &block)
	end
    end
end

gui = true
parser = OptionParser.new do |opts|
    opts.on("--[no-]gui", "(do not) start GUI") do |gui|
    end
end
parser.parse! ARGV
STDERR.puts gui

file = ARGV.shift
unless gui
    require 'roby/log/console'
    require 'roby/log/file'

    Roby::Log.loggers << Roby::Log::ConsoleLogger.new(STDOUT)
    Roby::Log.open(file, &Roby::Log::FileLogger.method(:replay))
    exit
end

require 'Qt'
require 'roby/log/offline_control_ui'
require 'roby/log/drb-qt'

module Roby::Log
    class DisplayControl < ::DisplayControl
	# The display server
	attr_reader :server
	# A relation_graph => checkbox hash
	attr_reader :relation_item
	# The log file IO object
	attr_reader :file
	# The time of the first sample
	attr_reader :first_sample
	# The time of the last sample
	attr_reader :last_sample
	# The time of the last successfully read sample
	attr_reader :current_time
	# The index of the last successfully read sample
	attr_reader :current_sample
	# The count of meaningful samples in file
	attr_reader :sample_count
	# The current logger object
	attr_reader :loggers
	# A relation => color hash
	attr_reader :relation_color
	# The last allocated color
	attr_reader :current_color

	# Base period for the playing timer
	PLAY_BASE_PERIOD = 0.1
	# Base period in samples when play_mode == :events
	PLAY_BASE_EVENTSTEP = 1

	COLORS = %w{'black' #800000 #008000 #000080 #C05800 #6633FF #CDBE70 #CD8162 #A2B5CD}
	# returns the next color in COLORS, cycles if at the end of the array
	def allocate_color
	    @current_color = (current_color + 1) % COLORS.size
	    COLORS[current_color]
	end

	# Sets the color display for the list item +item+
	def set_color_pixmap(item, color)
	    color_pix = Qt::Pixmap.new(50, item.height)
	    color_pix.fill Qt::Color.new(color)
	    item.set_pixmap 1, color_pix
	end

	# Changes the color for the relation currently selected in the list
	def change_color()
	    item = relation_display_list.current_item
	    return unless rel = relation_item.find { |_, i| i == item }

	    rel = rel.first
	    color = relation_color[rel] || 'black'

	    color = Qt::ColorDialog::get_color(Qt::Color.new(color))
	    relation_color[rel] = color.name
	    set_color_pixmap(item, color.name)
	end
	slots 'change_color()'

	# Add the relations in +relation_space+ to the relation list, using +root_item+ as
	# their parent item
	def setup_relations(relation_space, root_item)
	    relation_space.each_relation do |rel|
		name = rel.name.gsub(/.*Structure::/, '')
		color = relation_color[rel] = allocate_color
		item  = Qt::CheckListItem.new(root_item, name, Qt::CheckListItem::CheckBox)
		set_color_pixmap(item, color)

		relation_item[rel] = item
		relation_color[rel] = color
	    end
	    root_item.open = true
	end

	def initialize(*args, &block)
	    @server = Roby::Display::DRbDisplayServer.new(nil)
	    @current_color = -1
	    @relation_item = Hash.new
	    @relation_color = Hash.new

	    super(*args, &block)

	    Roby.load_all_relations

	    task_root = Qt::ListViewItem.new(relation_display_list, "Task relations")
	    event_root = Qt::ListViewItem.new(relation_display_list, "Event relations")
	    setup_relations(Roby::TaskStructure, task_root)
	    setup_relations(Roby::EventStructure, event_root)

	    @play_timer = Qt::Timer.new(self)
	    connect(@play_timer, SIGNAL('timeout()'), self, SLOT('play_step()'))

	    @loggers = Array.new

	    connect(relation_display_list, SIGNAL('doubleClicked( QListViewItem *, const QPoint &, int )'), 
		    self, SLOT('change_color()'))
	end

	def file_name; lbl_file_name.text end

	# Open a new file
	def open(file_name = nil)
	    loggers.each { |l| l.display.clear }

	    grp_display.enabled = false
	    grp_play.enabled = false

	    if file
		file.close 
		@file = nil
	    end

	    file_name ||= Qt::FileDialog.get_open_file_name
	    return unless file_name
	    lbl_file_name.text = file_name
	    
	    # Read the time of the first and last samples
	    unless (@file = Roby::Log.open(file_name) rescue nil)
		lbl_file_name.text = ''
		Qt::MessageBox.warning self, 'Cannot open file', "#{file_name} does not exist, is not readable, or is not a valid log file"
		return
	    end

	    rewind
	    sld_position.min_value = 0
	    sld_position.max_value = Integer(1000)

	    @current_time   = @first_sample
	    @current_sample = 0
	    @position = 0
	    change_play_mode

	    seek(0, true)

	    grp_display.enabled = true
	    grp_play.enabled    = true
	end

	def rewind
	    @first_sample, @last_sample = nil
	    file.rewind

	    @sample_count = 0
	    begin
		# Remove all cycle_end events at the top of the log
		loop do
		    m, time, _ = read_sample
		    next if m == :cycle_end

		    if @first_sample
			@sample_count += 1
		    else
			@first_sample = time
			@start	      = pos
		    end

		    @eof	  = pos
		    @last_sample  = time
		end
	    rescue EOFError
	    end

	    sld_position.value = 0
	    @current_time   = @first_sample
	    @current_sample = 0
	    @position = 0
	    change_play_mode
	    loggers.each { |l| l.display.clear }
	end

	# Reads data until the block returns true and sends samples
	# to the loggers. The block argument is the play position
	# (either the sample index or the sample time, according
	# to play_mode)
	def read_until
	    loop do
		if @next_sample
		    name, time, args = *@next_sample
		    @next_sample = nil
		else
		    name, time, args = read_sample
		end

		position = if play_mode == :time then
			       time - first_sample
			   else current_sample + 1
			   end

		if yield(position)
		    @next_sample = [name, time, args]
		    return
		end

		@current_time   = time
		@current_sample += 1
		@position = position
		Roby::Log.log(name, [time, *args])
	    end
	end

	# Min and max values for #position
	attr_reader :max, :position

	# Updates both the slider and the position display
	def update_position_display
	    sld_position.value = Integer(Float(position) / max * 1000)
	    dsp_position.num_digits = if position == 0 then 4
				      else Integer(Math.log10(position)) + 4
				      end

	    dsp_position.display(position)
	end

	def disable_updates
	    server.disable_updates
	    yield

	ensure
	    loggers.each { |l| l.flush }
	    server.enable_updates
	    server.update
	end


	# The timer which calls play_step when playing
	attr_reader :play_timer
	# The speed factor
	def play_speed; Float(edt_speed.text) end
	# The timer interval in milliseconds
	def play_timer_interval; Integer(PLAY_BASE_PERIOD * 1000) end

	# Called by a timer to send a time step to the display
	def play_step
	    disable_updates do
		old_pos = position
		limit = old_pos + step_size
		read_until { |pos| pos >= limit }
		@position = limit
	    end
	    update_position_display

	rescue
	    unless $!.kind_of?(EOFError)
		STDERR.puts $!.full_message
	    end
	    stop
	end

	def step_size
	    if play_mode == :time then
		PLAY_BASE_PERIOD * play_speed 
	    else
		PLAY_BASE_EVENTSTEP * play_speed
	    end
	end

	# Start playing at current position
	def play
	    if btn_play.on?
	        play_timer.start( play_timer_interval, false ) 
	    else
		stop
	    end
	end

	def stop
	    update_position_display
	    play_timer.stop
	    btn_play.set_on false
	end

	attr_reader :play_mode
	def change_play_mode
	    if btn_play_time.on? 
		@play_mode = :time
		@max = last_sample - first_sample
		@position = current_time - first_sample
		update_position_display
	    else 
		@play_mode = :events
		@max = sample_count
		@position = current_sample
		update_position_display
	    end
	end

	# Seek at pos +pos+. The position is given in seconds,
	# relative to beginning
	def seek(pos, force_reset = false)
	    if pos < 0 then pos = 0
	    elsif pos > max then pos = max
	    end

	    disable_updates do
		if force_reset || pos < position
		    rewind
		end

		read_until { |p| p >= pos } rescue nil
		@position = pos
	    end
	    update_position_display
	end
	def seek_start;    seek(0) end
	def seek_end;      seek(max) end
	def seek_previous; seek(position - step_size) end
	def seek_next;	   seek(position + step_size) end

	def slower; edt_speed.text = (play_speed / 2).to_s end
	def faster; edt_speed.text = (play_speed * 2).to_s end

	# Update the display
	def new_display
	    new_logger = if execution_flow.checked?
			     Roby::Display::ExecutionState.connect :server => server
			 else
			     relations = @relation_item.find_all { |_, item| item.on? }.map { |r, _| r }
			     relations = relations.inject({}) { |rels, r| rels[r] = relation_color[r]; rels }
			     Roby::Display::Relations.connect :server => server, :relations => relations
			 end

	    loggers << new_logger
	    replay
	end

	def replay
	    seek(position, true)
	end

    private
	def read_sample
	    raise EOFError if file.eof?

	    method_name = Marshal.load(file)
	    method_args = Marshal.load(file)
	    time = method_args.shift
	    return [method_name, time, method_args]

	rescue EOFError, TypeError, ArgumentError
	    raise EOFError
	end

    end
end

a = Qt::Application.new( ARGV )
display = Roby::Log::DisplayControl.new
display.show
display.open(file)
a.main_widget = display
a.exec()





