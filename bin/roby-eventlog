#! /usr/bin/ruby
require 'roby/log/offline_control_ui'
require 'roby/relations'
require 'roby/control'
require 'roby/log/logger'
require 'roby/log/drb'
require 'roby/log/drb-qt'
require 'roby/log/marshallable'

require 'roby/log/execution-state'
require 'roby/log/relations'

module Roby::Log
    class DisplayControl < ::DisplayControl
	# The display server
	attr_reader :server
	# A relation_graph => checkbox hash
	attr_reader :relations
	# The log file IO object
	attr_reader :file
	# The time of the first sample
	attr_reader :first_sample
	# The time of the last sample
	attr_reader :last_sample
	# The time of the last successfully read sample
	attr_reader :current_time
	# The current logger object
	attr_reader :loggers

	def initialize(*args, &block)
	    @server = Roby::Display::DRbDisplayServer.new(Roby::Display::DEFAULT_REMOTE_DISPLAY_URI)

	    super(*args, &block)

	    Roby.load_all_relations
	    @relations = Hash.new

	    task_root = Qt::ListViewItem.new(relation_display_list, "Task relations")
	    event_root = Qt::ListViewItem.new(relation_display_list, "Event relations")
	    setup_relations(Roby::TaskStructure, task_root)
	    setup_relations(Roby::EventStructure, event_root)

	    connect(btn_file_open, SIGNAL('pressed()'), self, SLOT('open()'))
	    connect(btn_new_display, SIGNAL('pressed()'), self, SLOT('new_display()'))
	    connect(btn_play, SIGNAL('toggled(bool)'), self, SLOT('play()'))
	    connect(btn_fast_forward, SIGNAL('pressed()'), self, SLOT('fast_forward()'))
	    connect(btn_seek_start, SIGNAL('pressed()'), self, SLOT('seek_start()'))
	    connect(btn_seek_end, SIGNAL('pressed()'), self, SLOT('seek_end()'))

	    @cycle_size = 0.1
	    @play_timer = Qt::Timer.new(self)
	    connect(@play_timer, SIGNAL('timeout()'), self, SLOT('play_step()'))

	    @loggers = Array.new
	end

	# Add the relations in +relation_space+ to the relation list, using +root_item+ as
	# their parent item
	def setup_relations(relation_space, root_item)
	    relation_space.each_relation do |rel|
		name = rel.name.gsub(/.*Structure::/, '')
		relations[rel] = Qt::CheckListItem.new(root_item, name, Qt::CheckListItem::CheckBox)
	    end
	    root_item.open = true
	end

	# Open a new file
	def open(file_name = nil)
	    loggers.each { |l| l.display.clear }

	    grp_display.enabled = false
	    grp_play.enabled = false

	    if file
		file.close 
		@file = nil
	    end

	    file_name ||= Qt::FileDialog.get_open_file_name
	    return unless file_name
	    lbl_file_name.text = file_name
	    
	    # Read the time of the first and last samples
	    @first_sample, @last_sample = nil
	    @file = File.open(file_name) rescue nil
	    unless @file
		lbl_file_name.text = ''
		Qt::MessageBox.warning self, 'Cannot open file', "#{file_name} does not exist, is not readable, or is not a valid log file"
		return
	    end

	    begin
		# Remove all cycle_end events at the top of the log
		loop do
		    pos, m, time, *_ = read_sample
		    next if m == :cycle_end

		    unless @first_sample
			@first_sample = time
			@start	      = pos
		    end
		    @eof	  = pos
		    @last_sample  = time
		end
	    rescue EOFError
	    end

	    sld_position.min_value = 0
	    sld_position.max_value = Integer((last_sample - first_sample) * 1000)

	    seek(0, true)

	    grp_display.enabled = true
	    grp_play.enabled    = true
	end
	slots 'open()'

	attr_reader :play_timer

	def read_sample
	    file_pos = file.tell

	    method_name = Marshal.load(file)
	    method_args = Marshal.load(file)
	    if method_name.to_s =~ /_relation$/
		method_args[1] = Module.constant(method_args[1])
	    end
	    return [file_pos, method_name, *method_args]

	rescue EOFError, TypeError, ArgumentError
	    file.seek(file_pos)
	    raise EOFError
	end

	# Read a step of data from the logfile and send it to Log
	def read_until(limit)
	    loop do
		pos, name, time, *args = read_sample
		if time >= limit
		    file.seek(pos)
		    @current_time = limit
		    break
		end

		@current_time = time
		Roby::Log.log(name, [time, *args])
	    end
	end

	def read_step
	    read_until(@current_time + step_size)
	end

	def update_position_display
	    int_pos = Integer((@current_time - first_sample) * 1000)
	    sld_position.value = int_pos

	    if int_pos == 0 then dsp_position.num_digits = 3
	    else dsp_position.num_digits = Integer(Math.log10(int_pos)) + 2
	    end

	    dsp_position.display(Float(int_pos) / 1000)
	end

	def disable_updates
	    server.disable_updates
	    yield

	ensure
	    loggers.each { |l| l.flush }
	    server.enable_updates
	    server.update
	end


	# Called by a timer to send a time step to the display
	def play_step
	    disable_updates { read_step }
	    update_position_display
	rescue EOFError
	    stop
	end
	slots 'play_step()'

	def play_position; first_sample + Float(sld_position.value) / 1000 end
	def play_speed; Float(edt_speed.text) end
	def play_timer_interval; Integer(cycle_size * 1000) end
	attr_reader :cycle_size
	def step_size; cycle_size * play_speed end

	# Start playing at current position
	def play
	    if btn_play.on?
	        play_timer.start( play_timer_interval, false ) 
	    else
		stop
	    end
	end
	slots 'play()'

	def stop
	    update_position_display
	    play_timer.stop
	    btn_play.set_on false
	end

	# Seek at pos +pos+. The position is given in seconds,
	# relative to beginning
	def seek(pos, force_reset = false)

	    if force_reset || (first_sample + pos) < play_position
		sld_position.value = 0
		@current_time = @first_sample

		file.seek(@start)
		loggers.each { |l| l.display.clear }
	    end

	    disable_updates do
		read_until(first_sample + pos) rescue nil
	    end
	    update_position_display
	end
	def seek_start; seek(0) end
	def seek_end; seek(last_sample - first_sample) end
	slots 'seek_start()', 'seek_end()'

	def fast_forward
	    edt_speed.text = (play_speed * 2).to_s
	    play_timer.change_interval play_timer_interval
	end
	slots 'fast_forward()'

	def file_name; lbl_file_name.text end

	# Update the display
	def new_display
	    new_logger = if execution_flow.checked?
			     Roby::Display::ExecutionState.connect :server => server
			 else
			     relations = @relations.find_all { |_, item| item.on? }.map { |r, _| r }
			     Roby::Display::Relations.connect :server => server, :relations => relations
			 end

	    loggers << new_logger
	    replay
	end
	slots 'new_display()'

	def replay
	    seek(play_position - first_sample, true)
	end
    end
end

if $0 == __FILE__
    require 'Qt'
    a = Qt::Application.new( ARGV )

    display = Roby::Log::DisplayControl.new
    display.show
    display.open(ARGV.shift)
    a.setMainWidget( display )
    a.exec()
end

