#! /usr/bin/env ruby
require 'roby'
require 'optparse'

def usage
    STDERR.puts <<-EOU
roby-log mode [options]
where the following modes are accepted:
    list-servers    lists the log servers available
    upgrade-format  upgrades an event log from an old format to the current one
    rebuild-index   rebuilds the index file for the given event log
    stats	    displays statistics about the given event log
    replay	    displays data saved in logged files
    display	    displays live data received from log servers
    help	    this help message

Call roby-log mode --help for more information about each mode
    EOU
end

STDOUT.sync = true

SERVER_LIST_TIMEOUT = 5
SERVER_LIST_POLL = 0.1
case mode = ARGV.shift
when "list-servers"
    DRb.start_service "druby://:0"

    require 'roby/log/server'
    puts "Finding available servers ... (#{SERVER_LIST_TIMEOUT} seconds)"

    broadcast = if ARGV.empty? then ['localhost']
		else ARGV
		end

    Roby::Log::Server.enable_discovery broadcast

    begin
	end_time = Time.now + SERVER_LIST_TIMEOUT
	known_servers = []
	while end_time > Time.now
	    sleep(SERVER_LIST_POLL)
	    Roby::Log::Server.available_servers.each do |server|
		next if known_servers.include?(server)
		known_servers << server

		remote = Roby::Log::Client.new(server)
		puts "#{server.__drburi}:"
		remote.streams.each do |s|
		    puts "  #{s.name} [#{s.type}]"
		end
	    end
	end
    rescue Interrupt
    end
    exit(0)

when "upgrade-format"
    require 'roby/log/file'
    Roby::Log::FileLogger.to_new_format(ARGV[0])
    exit(0)

when "rebuild-index"
    require 'roby/log/file'

    Roby::Log::Logfile.open(ARGV[0]) do |logfile|
	logfile.rebuild_index
    end
    exit(0)

when "stats"
    require 'roby/log/file'
    require 'roby/log/timings'

    filename = if ARGV[0] == "--csv"
		   do_csv = true
		   ARGV[1]
               elsif ARGV[0] == "--help"
                   puts "roby-log stats [--csv]"
                   puts "  displays statistics about the execution timings"
                   puts "  if the --csv option is given, a table with all"
                   puts "  the timings is output on stdout instead"
                   exit(0)
               else
		   ARGV[0]
	       end
    io = Roby::Log.open(filename)

    cycle_count = io.index_data.size
    timespan    = io.range
    puts "#{cycle_count} cycles between #{timespan.first.to_hms} and #{timespan.last.to_hms}"
    cpu_time = io.index_data.inject(0) { |old, info| old + info[:cpu_time] } / 1000
    real_time = timespan.last - timespan.first
    ratio = cpu_time / real_time
    puts "Time: %.2fs CPU / %.2fs real (%i%% CPU use)" % [cpu_time, real_time, ratio * 100]

    if io.index_data.first.has_key?(:event_count)
	min, max = nil
	event_count = io.index_data.inject(0) do |total, cycle_info|
	    count = cycle_info[:event_count]
	    min = count if !min || min > count
	    max = count if !max || max < count
	    total + count
	end
	puts "#{event_count} events, #{event_count / cycle_count} events/cycle (min: #{min}, max: #{max})"
    else
	puts "event count unavailable, please rebuild the index"
    end

    timings = Roby::Log::Timings.new(io)
    if do_csv
	timings.display(false)
    else
	timings.stats
    end
    exit(0)

when "replay"
    require 'roby/log/gui/replay'
    app  = Qt::Application.new(ARGV)

    main = Replay.setup(ARGV) do |main, parser, remaining|
	if remaining.empty?
	    if main.log_dir
		streams = Roby.app.data_streams(main.log_dir)
		streams.each do |stream|
		    stream.open
		    main.add_stream(stream)
		end
	    end
	else
	    remaining.each do |file|
		if streams = Roby.app.data_streams_of([file])
		    streams.each do |s|
			s.open
			main.add_stream(s)
		    end
		else
		    STDERR.puts "WARN: unknown file type for #{file}"
		end
	    end
	end
    end

    main.setup
    begin
	app.exec
    rescue
	STDERR.puts $!.full_message
    end

when "display"
    require 'roby/log/gui/runtime'
    DRb.start_service "druby://:0"
    Roby::Log::Server.logger.level = Logger::DEBUG

    broadcast = if ARGV.empty? then ['localhost']
		else ARGV
		end

    a = Qt::Application.new([])
    w = RuntimeDisplay.new(broadcast, Roby::Log::Server::RING_PORT, 5)
    w.show
    a.exec
    exit(0)

when "help"
    usage
    exit(0)

else
    STDERR.puts "no such mode of operation #{mode}"
    usage
    exit(1)
end

