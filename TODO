* error handling

* in #replace, use Hierarchy#fullfilled_events to check that
  all needed events are provided. If some are missing, use 
  define_event to try to add a new one dynamically

* when replacing an event generator, what to do with its handlers ?
  - either we discard them, because some handlers are used in a specific
    way
  - either we apply them on the new task
  - unfortunately there is no good answer... Both are useful and it is difficult
    (if not impossible) to know what to do. Having no solution for this problem
    reduces the usefulness of event handlers greatly.

* add per-model arguments attribute for tasks, which gives the list
  of expected arguments. These lists will then be used in fullfills? 
  checks. realized_by will use them too: if we give only a model
  and no arguments, initialize the argument list by taking only
  the needed arguments from the provided task.

* add a multiplicity parameter for hierarchy relations which tells
  how many child task of a given kind are expected by the parent
  task. Add a 'realized_by' transition for that. For instance, in
  case of Pom::Localization, we can tell that the task expects at
  least one Pom::Estimator. If the last estimator breaks, we can
  repair the plan online by adding a transition.

* abstract classes. Tasks like Roby::Task or yet-to-be-planned tasks are
  abstract since they will never be executable. Think about using modules to
  define some abstract tasks. This is possible since in effect, included modules
  look like base classes. However, we want to be able to make *some* abstract
  classes instanciable, so we can't use only modules

* a better synchronous event propagation based on continuations. When methods
  like happened? are called in a propagation context, and we don't know the 
  result yet (happened? = false), register a continuation and its dependency
  on the event. Call the continuation when we propagated the other branches of
  the context.

* gather all events before doing any propagation. This can be simply done by calling
  event_processing in a gather_propagation context

* make all tasks non-executable until the time they are inserted in a Plan.
  Check in #fired that the parent task *is* executable
  [DONE: 20061003150012-bd67f-d897752373b665e4707ff8d45cdbabcf7fda6c59]

* we NEED plan merging:
    - is we reuse a task which is already running, it should be transparent for
      the new process: this new task tree will call start!, but the task is running.
      Moreover, if it is synchronizing on the start event, it should appear "as if"
      the event has been emitted

