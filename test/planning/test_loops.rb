$LOAD_PATH.unshift File.expand_path(File.join('..', '..', 'lib'), File.dirname(__FILE__))
require 'roby/test/common'
require 'roby/planning'

require 'flexmock'
require 'roby/test/tasks/simple_task'

class TC_PlanningLoop < Test::Unit::TestCase
    include Roby::Planning
    include Roby::Test

    # The planner model
    attr_reader :planner_model
    # The task model
    attr_reader :task_model
    # The options to be used for the planning tasks generated by the loop
    # planner
    attr_reader :planning_task_options

    def setup
        super
	Roby.app.filter_backtraces = false

	task_model = @task_model = Class.new(SimpleTask)
        pattern_id = 0
	@planner_model = Class.new(Planning::Planner) do
	    method(:task) do
                pattern_id += 1
		task_model.new(:id => pattern_id)
	    end
	end

	@planning_task_options = {
	    :planning_owners => nil,
	    :planner_model => planner_model, 
	    :planned_model => SimpleTask, 
	    :planning_method => "task", 
	    :method_name => 'task', 
	    :method_options => {} }
    end

    def teardown
        @planner_model, @task_model, @planning_task_options = nil
        super
    end

    # Prepare the default plan for all planning loop tests
    def prepare_plan(loop_options = {})
	plan.add_mission(main_task = Roby::Task.new)
	loop_task_options = planning_task_options.merge(loop_options)
	loop_planner = PlanningLoop.new(loop_task_options)
	main_task.planned_by loop_planner

        return main_task, loop_planner
    end

    # Waits for +planning_task+ to finish and returns the planned result
    def planning_task_result(planning_task)
        assert(planning_task)
        assert(planning_task.running? || planning_task.success?, planning_task)
        if planning_task.running?
            planning_task.thread.join
            process_events
        end
	assert(planning_task.success?, planning_task.terminal_event.context)
	planning_task.planned_task
    end

    def test_append_pattern
        main_task, loop_planner = prepare_plan

	loop_planner.append_pattern
	assert_equal(1, main_task.children.to_a.size)
	first_task = main_task.children.find { true }
	assert_equal(SimpleTask, first_task.class)
	first_planner = first_task.planning_task
	assert_equal(0, first_planner.arguments[:method_options][:pattern_id])
	assert_equal(planning_task_options.merge(:method_options => { :pattern_id => 0 }), 
		     first_planner.arguments)
	assert_equal(1, loop_planner.patterns.size)

	loop_planner.append_pattern
	assert_equal(2, main_task.children.to_a.size)
	second_task = main_task.children.find { |t| t != first_task }
	assert_equal(SimpleTask, second_task.class)
	second_planner = second_task.planning_task
	assert_equal(planning_task_options.merge(:method_options => { :pattern_id => 1 }), 
		     second_planner.arguments)
	assert_equal(2, loop_planner.patterns.size)
    end

    # First use-case: non periodic loops with non-zero lookahead. It means that
    # a generated subplan will only be started if #loop_start! is called on the
    # loop planner, and that the system tries to always have some prepared
    # subplans ready to be executed.
    def test_nonperiodic
        main_task, loop_planner = prepare_plan :period => nil, :lookahead => 2
	loop_planner.start!

        # We have a lookahead of 2, so we should have two patterns. The first
        # planner should be already running but the second one should wait for
        # the first to finish
        assert_equal(2, loop_planner.patterns.size)
        first_planner = loop_planner.patterns[-1].first
        second_planner = loop_planner.patterns[-2].first
        assert(first_planner.running?)
        assert(!second_planner.running?)
	
        # Wait for the first two patterns to be planned and check the result.
        # The planned tasks should not be started until we call loop_start!
        # explicitely
	first_task = planning_task_result(first_planner)
	assert(second_planner.running?)
	assert_equal(1, first_task.arguments[:id])
	assert(!first_task.running?)
	assert_equal(2, loop_planner.patterns.size)

	second_task = planning_task_result(second_planner)
	assert_equal(2, second_task.arguments[:id])
	assert(!first_task.running?)
        assert(!second_task.running?)
	assert_equal(2, loop_planner.patterns.size)

        # Start the first pattern, check we have one more planner and that it
        # is running to keep the lookahead
	loop_planner.loop_start!
	assert(first_task.running?)
        assert(!second_task.running?)
	assert_equal(3, main_task.children.to_a.size)
        third_planner = loop_planner.last_planning_task
        assert(! [first_planner, second_planner].include?(third_planner))
        assert(third_planner.running?)

        # Stop the first task. We have no period here, so the second task
        # should not be running until we call #loop_start! again
	first_task.success!
	assert(!second_task.running?)
	loop_planner.loop_start!
	assert(second_task.running?)

        # We started the second pattern, so a fourth should be in preparation
        # since we did not call #process_events in the meantime, so the third
        # planner is still running from Roby's point of view
        fourth_planner = loop_planner.last_planning_task
        assert(! [first_planner, second_planner, third_planner].include?(fourth_planner))
        assert(third_planner.running?)
        assert(!fourth_planner.running?)

        # Now, we make the second task finish and call #loop_start! before
        # actually acknowledging the end of the third planner. The loop should
        # nicely handle that by starting the third task and the fourth planner
        # right after the end of planning.
	second_task.success!
	loop_planner.loop_start!
        assert(third_planner.running?)
        third_task = planning_task_result(third_planner)
	assert(third_task.running?)
	assert(fourth_planner.running?)
    end

    # Second use-case: periodic loops with non-zero lookahead. It means that a
    # generated subplan will be started either because #loop_start! is called
    # *or* because a specified timespan has been reached since the last pattern
    # end. The system tries to always have some prepared subplans ready to be
    # executed.
    def test_periodic
        main_task, loop_planner = prepare_plan :period => 1, :lookahead => 2
	loop_planner.start!

	FlexMock.use(Time) do |time_proxy|
	    current_time = Time.now + 5
	    time_proxy.should_receive(:now).and_return { current_time }

	    assert_equal(2, loop_planner.patterns.size)
	    first_planner  = loop_planner.patterns[-1].first
	    second_planner = loop_planner.patterns[-2].first
	    assert(first_planner.running?)
	    assert(!second_planner.running?)

	    # Call #loop_start! already, to make the loop start the first running
	    # task as soon as it is ready.
	    loop_planner.loop_start!

	    # Usual pattern: wait for the result of the first two planners, check
	    # that the first task actually runs
	    first_task  = planning_task_result(first_planner)
	    second_task = planning_task_result(second_planner)
	    third_planner = loop_planner.patterns[-3].first
	    assert(third_planner.running?)
	    assert(first_task.running?)
	    assert(second_task.pending?)

	    # Make the first task finish and make sure the system does not start it right away
	    first_task.success!
	    assert(first_task.success?)
	    assert(second_task.pending?)

	    current_time += 0.2
	    process_events
	    assert(second_task.pending?)

	    current_time += 0.8
	    process_events
	    assert(second_task.running?, loop_planner.arguments)

	    # Use the third task to check that the timeout can be overriden by
	    # calling loop_start! on the PlanningLoop task
	    third_task = planning_task_result(third_planner)

	    assert(second_task.running? && !third_task.running?)
	    second_task.success!
	    loop_planner.loop_start!
	    assert(!second_task.running? && third_task.running?)
	end
    end

    # Test periodic loop tasks with zero lookahead
    def test_periodic_zero_lookahead
	FlexMock.use(Time) do |time_proxy|
	    current_time = Time.now + 5
	    time_proxy.should_receive(:now).and_return { current_time }

	    main_task, loop_planner = prepare_plan :period => 0.5, :lookahead => 0
	    loop_planner.start!

	    # Zero lookahead: no children until we call #loop_start!
	    assert(main_task.children.empty?)

	    # Start a first pattern
	    loop_planner.loop_start!(:id => 1)
	    assert_equal(1, loop_planner.patterns.size)
	    first_planner = loop_planner.last_planning_task
	    first_task    = planning_task_result(first_planner)
	    assert_equal(1, first_task.arguments[:id])

	    # Check the normal behaviour: a new pattern is to be added only when
	    # the first pattern has finished AND the period has occured.
	    assert(first_task.running?)
	    assert_equal(1, main_task.children.to_a.size)
	    first_task.success!
	    assert_equal(1, main_task.children.to_a.size)
	    current_time += 0.6
	    process_events
	    assert_equal(2, main_task.children.to_a.size)
	    assert(second_planner = loop_planner.last_planning_task)
	    assert(second_planner.running?)
	    second_task = planning_task_result(second_planner)
	    assert(second_task.running?)
	    assert_equal(1, main_task.children.to_a.size)

	    # And queue one other. The second call to #loop_start! should be
	    # completely ignored because there is already one pending pattern.
	    loop_planner.loop_start!(:id => 3)
	    loop_planner.loop_start!(:id => 4)
	    assert_equal(2, main_task.children.to_a.size)
	    third_planner = loop_planner.last_planning_task
	    third_task  = planning_task_result(third_planner)
	    assert_equal(3, third_task.arguments[:id])

	    # Check the dynamic behaviour
	    # - the 3rd task should start as soon as the 2nd has: the call to
	    #   #loop_start! should have done that for us.
	    assert(second_task.running?)
	    assert(third_task.pending?)
	    second_task.success!
	    assert(second_task.success?)
	    assert(third_task.running?)
	    third_task.success!
	    assert(third_task.success?)
	end
    end

    def test_reinit_periodic
        main_task, loop_planner = prepare_plan :period => 0.5, :lookahead => 3

	FlexMock.use do |mock|
	    mock.should_receive(:started).twice
	    task_model.on(:start) { |ev| mock.started }

	    loop_planner.start!
            planners = loop_planner.patterns.reverse.map { |t, _| t }
            tasks    = planners.map { |p| planning_task_result(p) }

	    loop_planner.loop_start!
	    assert(tasks[0].running?)
            planning_task_result(loop_planner.patterns[0].first)

	    loop_planner.reinit!
            process_events
            process_events
            
            # reinit should keep the first pattern because it is running, but
            # the other ones should be new (and the second pattern should be
            # being planned)
            assert(loop_planner.event(:reinit).happened?)
            assert_equal(3, loop_planner.patterns.size)

            new_planners = loop_planner.patterns.reverse.map { |t, _| t }
            new_tasks    = new_planners.map { |p| planning_task_result(p) }

            new_tasks.each do |t|
                assert(!tasks.include?(t))
            end
            # assert_equal([1, 5, 6, 7], new_tasks.map { |t| t.arguments[:id] })
            # ... but the first pattern should be GCed right now, and the next
            # pattern started
	    process_events
	    assert(new_tasks[0].running?)
	end
    end

    #def test_planning_loop_reinit_zero_lookahead
    #    task_model = Class.new(SimpleTask)
    #    planner_model = Class.new(Planning::Planner) do 
    #        @@id = 0
    #        method(:task) do 
    #    	task_model.new(:id => (@@id += 1))
    #        end
    #    end

    #    plan.add_mission(main_task = Roby::Task.new)
    #    loop_planner = PlanningLoop.new :period => nil, :lookahead => 0, 
    #        :planner_model => planner_model, :planned_model => Roby::Task, 
    #        :method_name => :task, :method_options => {}	
    #    main_task.planned_by loop_planner


    #    FlexMock.use do |mock|
    #        mock.should_receive(:started).twice
    #        task_model.on(:start) { |ev| STDERR.puts "started pattern #{ev.task}"; mock.started }

    #        loop_planner.start!
    #        loop_planner.loop_start!
    #        first_task, first_planner = planning_loop_next(main_task)
    #        assert(first_task.running?)

    #        loop_planner.reinit
    #        loop_planner.loop_start!
    #        old_first = first_task
    #        first_task, first_planner   = planning_loop_next(main_task)
    #        assert_equal(2, first_task.arguments[:id])

    #        assert(old_first.running?)
    #        assert(first_task.pending?)

    #        process_events
    #        assert(old_first.finished?)
    #        assert(first_task.running?)
    #    end
    #end

    def test_make_loop
        planner_model = Class.new(Planning::Planner) do
            include Test::Unit::Assertions

            @result_task = nil
            attr_reader :result_task
            method(:task) {  @result_task = SimpleTask.new(:id => arguments[:task_id])}
            method(:looping_tasks) do
        	t1 = make_loop(:period => 0, :child_argument => 2) do
        	    # arguments of 'my_looping_task' shall be forwarded
        	    raise unless arguments[:parent_argument] == 1
        	    raise unless arguments[:child_argument] == 2
        	    task(:task_id => 'first_loop')
        	end
        	t2 = make_loop do
        	    task(:task_id => 'second_loop')
        	end
        	# Make sure the two loops are different
        	assert(t1.method_options[:id] != t2.method_options[:id])
        	[t1, t2]
            end
        end

        planner = planner_model.new(plan)
        t1, t2 = planner.looping_tasks(:parent_argument => 1)
        assert(t1.fully_instanciated?, t1.arguments.keys - t1.class.arguments.to_a)
        assert(t2.fully_instanciated?)
        plan.add_mission(t1)
        plan.add_mission(t2)

        t1.start!
        planned_task = planning_task_result(t1.last_planning_task)
        assert_equal('first_loop', planned_task.arguments[:id])

        t2.start!
        planned_task = planning_task_result(t2.last_planning_task)
        assert_equal('second_loop', planned_task.arguments[:id])

        t3 = planner.make_loop(:period => 0, :parent_argument => 1, :child_argument => 2) do
            task(:task_id => 'third_loop')
        end
        plan.add_mission(t3)
        t3.start!
        assert_equal('third_loop', planning_task_result(t3.last_planning_task).arguments[:id])
    end
end
